## **1. Pre-Requisites**
Ensure the following tools are installed on your local machine:
- **Terraform**: For provisioning cloud infrastructure.
- **Ansible**: For configuring servers and deploying applications.
- **Docker**: For building and pushing application images.
- **A Cloud Account**: AWS, GCP, or any supported provider.
- **Docker Hub Account**: To store and pull application images.

---

## **2. High-Level Architecture**

1. **Terraform Tasks**:
   - Provision cloud resources (e.g., virtual machines, networks).
   - Generate an inventory file for Ansible dynamically.
   - Trigger Ansible playbooks.

2. **Ansible Tasks**:
   - Configure servers (e.g., install Docker, set up firewalls).
   - Pull prebuilt Docker images from Docker Hub.
   - Deploy the application stack (frontend, backend, and database).
   - Deploy the monitoring stack (Prometheus, Grafana, cAdvisor).
   - Set up **NGINX** or **Traefik** for routing.

---

## **3. Step 1: Prepare Docker Images**

1. **Build Docker Images**:
   Ensure your frontend, backend, and database components are containerized and working locally.

2. **Push Images to Docker Hub**:
   ```bash
   docker login
   docker build -t <dockerhub-username>/frontend:latest ./frontend
   docker push <dockerhub-username>/frontend:latest

   docker build -t <dockerhub-username>/backend:latest ./backend
   docker push <dockerhub-username>/backend:latest
   ```

---

## **4. Step 2: Terraform Configuration**

### **4.1. Directory Structure**
```plaintext
terraform/
â”œâ”€â”€ main.tf                # Main Terraform configuration
â”œâ”€â”€ variables.tf           # Terraform variables
â”œâ”€â”€ outputs.tf             # Terraform outputs (e.g., IPs for Ansible)
â”œâ”€â”€ inventory.tpl          # Template for dynamic inventory
â””â”€â”€ ansible-playbook.tf    # Provisioning Ansible tasks
```

### **4.2. Terraform Code**

#### **main.tf**
Provision a VM and generate the necessary inventory:
```hcl
provider "aws" {
  region = "us-west-1" # Change to your desired region
}

resource "aws_instance" "app" {
  ami           = "ami-0c55b159cbfafe1f0" # Example Ubuntu AMI
  instance_type = "t2.micro"

  tags = {
    Name = "DevOps-Challenge-Instance"
  }

  provisioner "local-exec" {
    command = "echo ${aws_instance.app.public_ip} ansible_user=ubuntu > inventory"
  }
}

output "public_ip" {
  value = aws_instance.app.public_ip
}
```

#### **inventory.tpl**
A Jinja2 template for dynamic Ansible inventory:
```plaintext
[app]
{{ app_ip }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa
```

#### **ansible-playbook.tf**
Trigger Ansible playbooks using Terraform:
```hcl
resource "null_resource" "ansible" {
  provisioner "local-exec" {
    command = <<EOT
    ansible-playbook -i inventory playbook.yml
    EOT
  }
}
```

---

## **5. Step 3: Ansible Configuration**

### **5.1. Directory Structure**
```plaintext
ansible/
â”œâ”€â”€ playbook.yml            # Main playbook
â”œâ”€â”€ inventory               # Dynamic inventory (generated by Terraform)
â”œâ”€â”€ roles/
â”‚   â”œâ”€â”€ common/             # Install Docker and prerequisites
â”‚   â”œâ”€â”€ app/                # Deploy application stack
â”‚   â””â”€â”€ monitoring/         # Deploy monitoring stack
```

---

### **5.2. Ansible Playbook**

#### **playbook.yml**
The main playbook to configure the server and deploy the stacks:
```yaml
- name: Configure and deploy fullstack application
  hosts: all
  become: true
  roles:
    - common
    - app
    - monitoring
```

---

### **5.3. Ansible Roles**

#### **Role: Common**
Set up Docker and prerequisites.

**Tasks: `roles/common/tasks/main.yml`**
```yaml
- name: Update apt packages
  apt:
    update_cache: yes
    cache_valid_time: 3600

- name: Install Docker
  apt:
    name:
      - docker.io
      - docker-compose
    state: present

- name: Ensure Docker is running
  service:
    name: docker
    state: started
    enabled: true
```

---

#### **Role: App**
Pull and deploy the application stack.

**Tasks: `roles/app/tasks/main.yml`**
```yaml
- name: Pull backend Docker image
  command: docker pull <dockerhub-username>/backend:latest

- name: Pull frontend Docker image
  command: docker pull <dockerhub-username>/frontend:latest

- name: Start backend container
  docker_container:
    name: backend
    image: <dockerhub-username>/backend:latest
    ports:
      - "8000:8000"

- name: Start frontend container
  docker_container:
    name: frontend
    image: <dockerhub-username>/frontend:latest
    ports:
      - "5173:80"
```

---

#### **Role: Monitoring**
Deploy Prometheus, Grafana, and cAdvisor.

**Tasks: `roles/monitoring/tasks/main.yml`**
```yaml
- name: Pull Prometheus Docker image
  command: docker pull prom/prometheus:latest

- name: Pull Grafana Docker image
  command: docker pull grafana/grafana:latest

- name: Pull cAdvisor Docker image
  command: docker pull gcr.io/cadvisor/cadvisor:latest

- name: Start Prometheus container
  docker_container:
    name: prometheus
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

- name: Start Grafana container
  docker_container:
    name: grafana
    image: grafana/grafana:latest
    ports:
      - "3000:3000"

- name: Start cAdvisor container
  docker_container:
    name: cadvisor
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
```

---

## **6. Automating Everything**

With this setup, running `terraform apply -auto-approve` will:
1. **Provision Cloud Resources**:
   - Terraform provisions the instance on AWS (or other providers).
2. **Generate Dynamic Inventory**:
   - Terraform generates the Ansible inventory file.
3. **Trigger Ansible**:
   - Terraform triggers Ansible playbooks to configure the server, deploy the application, and set up monitoring.

---

## **7. Testing the Deployment**

1. Run the entire pipeline:
   ```bash
   terraform init
   terraform apply -auto-approve
   ```
2. Access the services:
   - **Frontend**: `http://<server-ip>:5173`
   - **Backend**: `http://<server-ip>:8000`
   - **Prometheus**: `http://<server-ip>:9090`
   - **Grafana**: `http://<server-ip>:3000`

---

## **8. Why This Approach Works**

1. **Terraform for Infrastructure**:
   - Ensures infrastructure is consistent and repeatable.
   - Dynamically generates inventory, so thereâ€™s no need for manual configuration.

2. **Ansible for Configuration**:
   - Simplifies server setup and application deployment.
   - Roles allow modular and reusable configurations.

3. **Docker for Portability**:
   - Containers ensure the application runs the same way in any environment.

---

Let me know if you need further clarification or help with any step! ðŸ˜Š